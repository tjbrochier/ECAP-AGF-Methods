function varargout = ipgEffectCalculator(varargin)
% IPGEFFECTCALCULATOR MATLAB code for ipgEffectCalculator.fig
%      IPGEFFECTCALCULATOR, by itself, creates a new IPGEFFECTCALCULATOR or raises the existing
%      singleton*.
%
%      H = IPGEFFECTCALCULATOR returns the handle to a new IPGEFFECTCALCULATOR or the handle to
%      the existing singleton*.
%
%      IPGEFFECTCALCULATOR('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in IPGEFFECTCALCULATOR.M with the given input arguments.
%
%      IPGEFFECTCALCULATOR('Property','Value',...) creates a new IPGEFFECTCALCULATOR or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before ipgEffectCalculator_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to ipgEffectCalculator_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help ipgEffectCalculator

% Last Modified by GUIDE v2.5 28-Oct-2019 18:46:41

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @ipgEffectCalculator_OpeningFcn, ...
                   'gui_OutputFcn',  @ipgEffectCalculator_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before ipgEffectCalculator is made visible.
function ipgEffectCalculator_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to ipgEffectCalculator (see VARARGIN)

% Choose default command line output for ipgEffectCalculator
handles.output = hObject;

% Update handles structure
handles.ipgShort_plotFlag = 0;
handles.ipgLong_plotFlag = 0;
handles.limits_plotFlag = 0;


xlabel('Input Current (dB re 1 uA)')
ylabel('eCAP Output Voltage (dB re 1 uV)')



guidata(hObject, handles);

% UIWAIT makes ipgEffectCalculator wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = ipgEffectCalculator_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% --- Executes on button press in get_ipgShortFilename.
function get_ipgShortFilename_Callback(hObject, eventdata, handles)
% hObject    handle to get_ipgShortFilename (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
readingFileFlag = 1;

while readingFileFlag == 1
    
set(handles.get_ipgShortFilename,'String','Reading file...')
set(handles.get_ipgShortFilename,'Enable','off')
set(handles.get_ipgLongFilename,'Enable','off')
set(handles.initialize_limits, 'Enable','off')

[handles.filename_ipgShort handles.pathname_ipgShort] = uigetfile('*.xlsx; *.mat','Choose ECAP Amplitude Growth Measurement File...');

if handles.filename_ipgShort == 0
    set(handles.get_ipgShortFilename,'String','Browse for IPG Short Filename...')
    set(handles.get_ipgShortFilename,'Enable','on')
    set(handles.get_ipgLongFilename,'Enable','on')
    set(handles.initialize_limits, 'Enable','on')
    readingFileFlag = 0;
end


set(handles.display_ipgShortFilename,'String',handles.filename_ipgShort);

[status,sheets] = xlsfinfo([handles.pathname_ipgShort handles.filename_ipgShort]);

if length(sheets) == 4  %ECAP Outputs generated by Custom Sound EP (from Cochlear) are 4 sheets long 
    [options, peaks] = get_eCAP_from_xls_FAST([handles.pathname_ipgShort handles.filename_ipgShort]);
    output_ipgShort= [peaks.N1P1_Amplitude_uV];                    %Output ECAP voltage in microvolts
    input_ipgShort = [options.Probe_Current_Level];                %Input current levels in Cochlear CL steps
    input_ipgShort = 17.5*100.^(input_ipgShort./255);              %Convert input current levels to microamps
    
elseif length(sheets) == 1 %If you want to use Advanced Bionics or MedEl ECAP data, simply make an excel sheet where the first column is input current in uA and the second column is ECAP N1P2 peak output in uV
    ECAP_data_ipgShort = readmatrix([handles.pathname_ipgShort handles.filename_ipgShort]);
    output_ipgShort = ECAP_data_ipgShort(:,2);    %ECAP N1P2 peak output in column 2 of excel file 
    input_ipgShort = ECAP_data_ipgShort(:,1);     %Input current IN MICROAMPS in column 1 of excel file
    
end
    




%Remove measurements that did not produce an ECAP, and store their indices
zeroIndex = find(output_ipgShort == 0);
output_ipgShort(output_ipgShort == 0) = [];

output_ipgShort_dB = zeros(1,length(output_ipgShort));

for i = 1:length(output_ipgShort)
    output_ipgShort_dB(i) = 20*log10(output_ipgShort(i));                %Convert output ECAP voltage to dB re 1 uV
    
end

%because we are doing interpolation later, ensure all values of output are
%unique...we do this by adding 0.1 to the repeated output value. For
%example, if a CL input of 154 and 158 both generate an ECAP of 32.4 dB re
%1 uV, then add 0.1 to the ECAP output at 158, so that the interpolation
%function works.

[~,ind] = unique(output_ipgShort_dB);
duplicate_ind = setdiff(1:length(output_ipgShort_dB),ind);
output_ipgShort_dB(duplicate_ind) = output_ipgShort_dB(duplicate_ind) + 0.1;

input_ipgShort(:,zeroIndex) = [];
input_ipgShort_dB = zeros(1,length(input_ipgShort));

for i = 1:length(input_ipgShort)
    input_ipgShort_dB(i) = 20*log10(input_ipgShort(i));                %Convert output ECAP voltage to dB re 1 uV
    
end

handles.output_ipgShort = output_ipgShort_dB;
handles.input_ipgShort = input_ipgShort_dB;


if handles.ipgShort_plotFlag == 0                                           %%if this is the first plot since the GUI opened, plot the initial ECAP AGF
    hold on
    set(handles.get_ipgShortFilename,'String','Plotting ECAP AGF...')
    handles.ipgShort_plot_handle = plot(handles.input_ipgShort, handles.output_ipgShort,'-s', 'DisplayName', 'IPG Short AGF','LineWidth',3,'MarkerSize',7);
    handles.ipgShort_plotFlag = 1;
    legend('Location','northwest')
    readingFileFlag = 0;
else                                                                        %% if this is not the first plot, reset the values to the new ECAP AGF file
    set(handles.get_ipgShortFilename,'String','Plotting ECAP AGF...')
    set(handles.ipgShort_plot_handle, 'XData', handles.input_ipgShort,'YData',handles.output_ipgShort);
    %set(handles.ipgShort_scatter_handle, 'XData', handles.input_ipgShort,'YData',handles.output_ipgShort);
    readingFileFlag = 0;
end

end

set(handles.get_ipgShortFilename,'String','Browse for IPG Short Filename...')
set(handles.get_ipgShortFilename,'Enable','on')
set(handles.get_ipgLongFilename,'Enable','on')
set(handles.initialize_limits, 'Enable','on')

guidata(hObject, handles);
    
    




% --- Executes on button press in get_ipgLongFilename.
function get_ipgLongFilename_Callback(hObject, eventdata, handles)
% hObject    handle to get_ipgLongFilename (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
readingFileFlag = 1;


while readingFileFlag == 1
    
set(handles.get_ipgLongFilename,'String','Reading file...')
set(handles.get_ipgLongFilename,'Enable','off')
set(handles.get_ipgShortFilename,'Enable','off')
set(handles.initialize_limits, 'Enable','off')

[handles.filename_ipgLong handles.pathname_ipgLong] = uigetfile('*.xlsx','Choose ECAP Amplitude Growth Measurement File...');

if handles.filename_ipgLong == 0
    set(handles.get_ipgLongFilename,'String','Browse for IPG Short Filename...')
    set(handles.get_ipgLongFilename,'Enable','on')
    set(handles.get_ipgShortFilename,'Enable','on')
    set(handles.initialize_limits, 'Enable','on')
    readingFileFlag = 0;
end

set(handles.display_ipgLongFilename,'String',handles.filename_ipgLong);

[status,sheets] = xlsfinfo([handles.pathname_ipgLong handles.filename_ipgLong]);

if length(sheets) == 4  %ECAP Outputs generated by Custom Sound EP (from Cochlear) are 4 sheets long 
    [options, peaks] = get_eCAP_from_xls_FAST([handles.pathname_ipgLong handles.filename_ipgLong]);
    output_ipgLong= [peaks.N1P1_Amplitude_uV];                    %Output ECAP voltage in microvolts
    input_ipgLong = [options.Probe_Current_Level];                %Input current levels in Cochlear CL steps
    input_ipgLong = 17.5*100.^(input_ipgLong./255);              %Convert input current levels to microamps
    
elseif length(sheets) == 1 %If you want to use Advanced Bionics or MedEl ECAP data, simply make an excel sheet where the first column is input current in uA and the second column is ECAP N1P2 peak output in uV
    ECAP_data_ipgLong = readmatrix([handles.pathname_ipgLong handles.filename_ipgLong]);
    output_ipgLong = ECAP_data_ipgLong(:,2);    %ECAP N1P2 peak output in column 2 of excel file 
    input_ipgLong = ECAP_data_ipgLong(:,1);     %Input current IN MICROAMPS in column 1 of excel file
    
end


%Remove measurements that did not produce an ECAP, and store their indices
zeroIndex = find(output_ipgLong == 0);
output_ipgLong(output_ipgLong == 0) = [];

output_ipgLong_dB = zeros(1,length(output_ipgLong));

for i = 1:length(output_ipgLong)
    output_ipgLong_dB(i) = 20*log10(output_ipgLong(i));                %Convert output ECAP voltage to dB re 1 uV
    
end

[~,ind] = unique(output_ipgLong_dB);
duplicate_ind = setdiff(1:length(output_ipgLong_dB),ind);
output_ipgLong_dB(duplicate_ind) = output_ipgLong_dB(duplicate_ind) + 0.1;

input_ipgLong(:,zeroIndex) = [];
input_ipgLong_dB = zeros(1,length(input_ipgLong));

for i = 1:length(input_ipgLong)
    input_ipgLong_dB(i) = 20*log10(input_ipgLong(i));                %Convert output ECAP voltage to dB re 1 uV
    
end


handles.output_ipgLong = output_ipgLong_dB;
handles.input_ipgLong = input_ipgLong_dB;


if handles.ipgLong_plotFlag == 0                                            %%if this is the first plot since the GUI opened, plot the initial ECAP AGF
    set(handles.get_ipgLongFilename,'String','Plotting ECAP AGF...')
    hold on
    handles.ipgLong_plot_handle = plot(handles.input_ipgLong, handles.output_ipgLong, '-o','DisplayName', 'IPG Long AGF','LineWidth',3,'MarkerSize',7);
    handles.ipgLong_plotFlag = 1;
    readingFileFlag = 0;
else                                                                        %% if this is not the first plot, reset the values to the new ECAP AGF file
    set(handles.get_ipgLongFilename,'String','Plotting ECAP AGF...')
    set(handles.ipgLong_plot_handle, 'XData', handles.input_ipgLong,'YData',handles.output_ipgLong);
    %set(handles.ipgLong_scatter_handle, 'XData', handles.input_ipgLong,'YData',handles.output_ipgLong);
    readingFileFlag = 0;
end

end

set(handles.get_ipgLongFilename,'String','Browse for IPG Long Filename...')
set(handles.get_ipgLongFilename,'Enable','on')
set(handles.get_ipgShortFilename,'Enable','on')
set(handles.initialize_limits, 'Enable','on')
    

guidata(hObject, handles);


% --- Executes on slider movement.
function upperLimit_slider_Callback(hObject, eventdata, handles)
% hObject    handle to upperLimit_slider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'Value') returns position of slider
%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider

currentSliderValue = get(handles.upperLimit_slider,'Value'); 
set(handles.upperLimit_plot_handle, 'XData', handles.inputRange,'YData',ones(length(handles.inputRange),1).*currentSliderValue);
handles.upperLimit_sliderValue = currentSliderValue;
set(handles.display_upperLimit,'String', ['Upper Limit:' ' ' num2str(currentSliderValue) ' ' 'dB re 1 uV']);

guidata(hObject, handles);



% --- Executes during object creation, after setting all properties.
function upperLimit_slider_CreateFcn(hObject, eventdata, handles)
% hObject    handle to upperLimit_slider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: slider controls usually have a light gray background.
if isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor',[.9 .9 .9]);
end


% --- Executes on slider movement.
function lowerLimit_slider_Callback(hObject, eventdata, handles)
% hObject    handle to lowerLimit_slider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'Value') returns position of slider
%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider

currentSliderValue = get(handles.lowerLimit_slider,'Value'); 
set(handles.lowerLimit_plot_handle, 'XData', handles.inputRange,'YData',ones(length(handles.inputRange),1).*currentSliderValue);
handles.lowerLimit_sliderValue = currentSliderValue;
set(handles.display_lowerLimit,'String', ['Lower Limit:' ' ' num2str(currentSliderValue) ' ' 'dB re 1 uV']);

guidata(hObject, handles);


% --- Executes during object creation, after setting all properties.
function lowerLimit_slider_CreateFcn(hObject, eventdata, handles)
% hObject    handle to lowerLimit_slider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: slider controls usually have a light gray background.
if isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor',[.9 .9 .9]);
end


% --- Executes on button press in initialize_limits.
function initialize_limits_Callback(hObject, eventdata, handles)
% hObject    handle to initialize_limits (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

handles.sliderMax = min([max(handles.output_ipgShort) max(handles.output_ipgLong)]);
handles.sliderMin = max([min(handles.output_ipgShort) min(handles.output_ipgLong)]);
if max(handles.output_ipgLong) > max(handles.output_ipgShort)
    handles.upperLimit_initial = max(handles.output_ipgShort);
else
    handles.upperLimit_initial = max(handles.output_ipgLong);
end

if min(handles.output_ipgShort) < min(handles.output_ipgLong)
    handles.lowerLimit_initial = min(handles.output_ipgLong);
else
    handles.lowerLimit_initial = min(handles.output_ipgShort);
end
    
set(handles.upperLimit_slider,'max',handles.sliderMax);
set(handles.upperLimit_slider,'value',handles.upperLimit_initial);
set(handles.upperLimit_slider,'min',handles.sliderMin);
  
set(handles.lowerLimit_slider,'max',handles.sliderMax);
set(handles.lowerLimit_slider,'value',handles.lowerLimit_initial);
set(handles.lowerLimit_slider,'min',handles.sliderMin);

handles.inputMin = min([handles.input_ipgShort handles.input_ipgLong]);
handles.inputMax = max([handles.input_ipgShort handles.input_ipgLong]);
handles.inputRange = handles.inputMin:1:handles.inputMax;
handles.upperLimit_sliderValue = get(handles.upperLimit_slider,'value');
handles.upperLimit = handles.upperLimit_sliderValue*ones(length(handles.inputRange),1);
handles.lowerLimit_sliderValue = get(handles.lowerLimit_slider,'value');
handles.lowerLimit = handles.lowerLimit_sliderValue*ones(length(handles.inputRange),1);

if handles.limits_plotFlag == 0
    hold on
    handles.upperLimit_plot_handle = plot(handles.inputRange, handles.upperLimit,'--','DisplayName', 'Upper Limit','LineWidth',2);
    handles.lowerLimit_plot_handle = plot(handles.inputRange, handles.lowerLimit,'--','DisplayName', 'Lower Limit','LineWidth',2);
    handles.limits_plotFlag = 1;
    set(handles.display_upperLimit,'String',['Upper Limit:' ' ' num2str(handles.upperLimit_initial) ' ' 'dB re 1 uV']);
    set(handles.display_lowerLimit,'String',['Lower Limit:' ' ' num2str(handles.lowerLimit_initial) ' ' 'dB re 1 uV']);
else
    set(handles.upperLimit_plot_handle, 'XData', handles.inputRange,'YData',handles.upperLimit);
    set(handles.lowerLimit_plot_handle, 'XData', handles.inputRange,'YData',handles.lowerLimit);
end
    
    
    guidata(hObject, handles)


% --- Executes on button press in calculate_ipgEffect.
function calculate_ipgEffect_Callback(hObject, eventdata, handles)
% hObject    handle to calculate_ipgEffect (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

handles.ipgShortVector = zeros(length(handles.lowerLimit_sliderValue:0.1:handles.upperLimit_sliderValue),1);
handles.ipgLongVector = zeros(length(handles.lowerLimit_sliderValue:0.1:handles.upperLimit_sliderValue),1);
k = 1;

for i= handles.lowerLimit_sliderValue:0.1:handles.upperLimit_sliderValue
    
    handles.ipgShortVector(k) = interp1(handles.output_ipgShort,handles.input_ipgShort,i);
    handles.ipgLongVector(k) = interp1(handles.output_ipgLong,handles.input_ipgLong,i);
    k = k+1;
    
end

handles.ipgEffectVector = handles.ipgShortVector - handles.ipgLongVector;
handles.ipgEffect = mean(handles.ipgEffectVector);

set(handles.display_ipgEffect,'String',[num2str(handles.ipgEffect) ' ' 'dB']);

guidata(hObject, handles)


    
